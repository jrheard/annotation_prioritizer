"""Core data models for the type annotation priority analyzer.

Data Flow Through Models:
    1. FunctionInfo: Extracted from AST by function_parser
    2. CallCount: Generated by call_counter for each FunctionInfo
    3. AnnotationScore: Calculated by scoring module from FunctionInfo
    4. FunctionPriority: Combines all metrics for final prioritization
    5. UnresolvableCall: Tracks calls that couldn't be resolved statically
    6. AnalysisResult: Complete analysis including priorities and unresolvable calls
"""

from collections.abc import Mapping
from dataclasses import dataclass
from enum import StrEnum
from pathlib import Path
from typing import NewType

# Define the new type for qualified names like "__module__.ClassName.method"
QualifiedName = NewType("QualifiedName", str)


def make_qualified_name(name: str) -> QualifiedName:
    """Create a QualifiedName from a string.

    This is the only way to create a QualifiedName, ensuring type safety.

    Args:
        name: A qualified name string like "__module__.ClassName.method"

    Returns:
        A QualifiedName instance
    """
    return QualifiedName(name)


class ScopeKind(StrEnum):
    """Enumeration of scope types for tracking nested definitions."""

    MODULE = "module"
    CLASS = "class"
    FUNCTION = "function"


@dataclass(frozen=True)
class Scope:
    """Represents a scope context for building qualified names.

    Used to track the nested context of functions and classes during AST
    traversal to build accurate qualified names that reflect the true
    scope hierarchy.
    """

    kind: ScopeKind  # Type of scope (module, class, or function)
    name: str  # Name of the scope (class name or function name)


type ScopeStack = tuple[Scope, ...]


class NameBindingKind(StrEnum):
    """Type of name binding in the AST."""

    IMPORT = "import"  # from math import sqrt
    FUNCTION = "function"  # def foo(): ...
    CLASS = "class"  # class Calculator: ...
    VARIABLE = "variable"  # calc = Calculator()


@dataclass(frozen=True)
class NameBinding:
    """A name binding at a specific position in the code.

    Represents any name that gets bound in Python code, including imports,
    function definitions, class definitions, and variable assignments.
    Used to track name bindings with their line numbers for position-aware
    name resolution.

    Attributes:
        name: Local name like "sqrt", "Calculator"
        line_number: Where defined/imported (1-indexed)
        kind: Type of binding (import, function, class, variable)
        qualified_name: Full qualified name, None for imports in Phase 1
        scope_stack: Full scope stack where binding occurs
        source_module: For imports: "math" from "from math import sqrt"
        target_class: For variables: class they're instances of
    """

    name: str  # Local name like "sqrt", "Calculator"
    line_number: int  # Where defined/imported (1-indexed)
    kind: NameBindingKind  # Type of binding
    qualified_name: QualifiedName | None  # None for imports (Phase 1)
    scope_stack: ScopeStack  # Full scope stack where binding occurs
    source_module: str | None  # For imports: "math" from "from math import sqrt"
    target_class: QualifiedName | None  # For variables: class they're instances of


type LineBinding = tuple[int, NameBinding]
"""A name binding at a specific line number.

Used in PositionIndex for binary search: the int is the line number where
the binding occurs, and the NameBinding contains the binding information.
These are kept sorted by line number for efficient lookup.
"""


type PositionIndex = Mapping[QualifiedName, dict[str, list[LineBinding]]]
"""Position-aware name resolution index.

Maps scope qualified names to dictionaries of names, which map to sorted lists
of (line_number, binding) tuples for binary search lookup.

Example structure for this code:
    import math                  # line 1

    class Calculator:            # line 5
        def add(self, a, b):     # line 6
            return a + b
        def multiply(self, a, b): # line 9
            return a * b

    {
        "__module__": {
            "math": [(1, NameBinding(..., kind=IMPORT))],
            "Calculator": [(5, NameBinding(..., kind=CLASS))]
        },
        "__module__.Calculator": {
            "add": [(6, NameBinding(..., kind=FUNCTION))],
            "multiply": [(9, NameBinding(..., kind=FUNCTION))]
        }
    }

Create with build_position_index() from position_index module.
Use with resolve_name() for position-aware name resolution.
"""


@dataclass(frozen=True)
class ParameterInfo:
    """Information about a function parameter.

    Represents a single parameter from a function signature, including
    special parameters like self, cls, *args, and **kwargs. Used by
    the scoring system to calculate annotation completeness.

    Note: 'self' and 'cls' parameters are included but treated as
    implicitly annotated during scoring calculations.
    """

    name: str  # Parameter name as it appears in the signature (e.g., 'self', 'data')
    has_annotation: bool  # Whether the parameter has a type annotation
    is_variadic: bool  # True for *args parameters (mutually exclusive with is_keyword)
    is_keyword: bool  # True for **kwargs parameters (mutually exclusive with is_variadic)


@dataclass(frozen=True)
class FunctionInfo:
    """Information about a function definition extracted from AST.

    Represents a complete function or method definition with its signature
    and location information. The qualified_name uniquely identifies the
    function within its module scope.

    Qualified Name Format:
        - Module function: "__module__.function_name"
        - Class method: "__module__.ClassName.method_name"
        - Nested class method: "__module__.OuterClass.InnerClass.method_name"
    """

    name: str  # Local function name (e.g., 'add')
    qualified_name: (
        QualifiedName  # Full name with complete scope hierarchy (e.g., '__module__.Calculator.add')
    )
    parameters: tuple[ParameterInfo, ...]  # All parameters in definition order
    has_return_annotation: bool  # Whether return type is annotated
    line_number: int  # Line where function is defined (1-indexed)
    file_path: Path  # Path to source file (as provided, can be absolute or relative)


@dataclass(frozen=True)
class CallCount:
    """Call count information for a function.

    Tracks how many times a function is called within the analyzed scope.
    Functions with zero calls are still included to distinguish between
    "not called" and "not found".
    """

    function_qualified_name: (
        QualifiedName  # Must match FunctionInfo.qualified_name exactly (e.g., "__module__.Calculator.add")
    )
    call_count: int  # Number of resolved calls (can be 0)


@dataclass(frozen=True)
class AnnotationScore:
    """Annotation completeness scores for a function.

    Scores represent how fully annotated a function is, used to identify
    functions that need type annotations. The total_score combines
    parameter and return scores with configurable weights.

    Special Cases:
        - Functions with no parameters get parameter_score = 1.0
        - 'self' and 'cls' parameters are excluded from scoring
    """

    function_qualified_name: (
        QualifiedName  # Identifies the scored function (e.g., "__module__.Calculator.add")
    )
    parameter_score: float  # Ratio of annotated parameters (0.0 to 1.0)
    return_score: float  # 1.0 if return annotated, 0.0 otherwise
    total_score: float  # Weighted combination (0.0 = no annotations, 1.0 = fully annotated)


@dataclass(frozen=True)
class FunctionPriority:
    """Complete priority analysis for a function.

    Combines all metrics to produce a final priority score for annotation.
    Higher scores indicate functions that should be prioritized for adding
    type annotations (frequently called but poorly annotated).
    """

    function_info: FunctionInfo  # Complete function metadata
    annotation_score: AnnotationScore  # Annotation completeness metrics
    call_count: int  # Number of times function is called
    priority_score: float  # Final priority for annotation (higher = more urgent)


@dataclass(frozen=True)
class UnresolvableCall:
    """Information about a call that couldn't be resolved.

    Provides context about calls the tool couldn't count,
    helping users understand coverage limitations.
    """

    line_number: int  # Line where the unresolvable call appears
    call_text: str  # First 50 chars of the call for context


@dataclass(frozen=True)
class AnalysisResult:
    """Complete result from analyzing a file.

    Contains both the prioritized functions and all calls that
    couldn't be resolved, providing full transparency.
    """

    priorities: tuple[FunctionPriority, ...]
    unresolvable_calls: tuple[UnresolvableCall, ...]
