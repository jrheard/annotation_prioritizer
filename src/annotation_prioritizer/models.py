"""Core data models for the type annotation priority analyzer.

Data Flow Through Models:
    1. FunctionInfo: Extracted from AST by function_parser
    2. CallCount: Generated by call_counter for each FunctionInfo
    3. AnnotationScore: Calculated by scoring module from FunctionInfo
    4. FunctionPriority: Combines all metrics for final prioritization
    5. UnresolvableCall: Tracks calls that couldn't be resolved statically
    6. AnalysisResult: Complete analysis including priorities and unresolvable calls
"""

from dataclasses import dataclass
from enum import StrEnum
from pathlib import Path
from typing import NewType

# Define the new type for qualified names like "__module__.ClassName.method"
QualifiedName = NewType("QualifiedName", str)


def make_qualified_name(name: str) -> QualifiedName:
    """Create a QualifiedName from a string.

    This is the only way to create a QualifiedName, ensuring type safety.

    Args:
        name: A qualified name string like "__module__.ClassName.method"

    Returns:
        A QualifiedName instance
    """
    return QualifiedName(name)


class ScopeKind(StrEnum):
    """Enumeration of scope types for tracking nested definitions."""

    MODULE = "module"
    CLASS = "class"
    FUNCTION = "function"


@dataclass(frozen=True)
class Scope:
    """Represents a scope context for building qualified names.

    Used to track the nested context of functions and classes during AST
    traversal to build accurate qualified names that reflect the true
    scope hierarchy.
    """

    kind: ScopeKind  # Type of scope (module, class, or function)
    name: str  # Name of the scope (class name or function name)


@dataclass(frozen=True)
class ParameterInfo:
    """Information about a function parameter.

    Represents a single parameter from a function signature, including
    special parameters like self, cls, *args, and **kwargs. Used by
    the scoring system to calculate annotation completeness.

    Note: 'self' and 'cls' parameters are included but treated as
    implicitly annotated during scoring calculations.
    """

    name: str  # Parameter name as it appears in the signature (e.g., 'self', 'data')
    has_annotation: bool  # Whether the parameter has a type annotation
    is_variadic: bool  # True for *args parameters (mutually exclusive with is_keyword)
    is_keyword: bool  # True for **kwargs parameters (mutually exclusive with is_variadic)


@dataclass(frozen=True)
class FunctionInfo:
    """Information about a function definition extracted from AST.

    Represents a complete function or method definition with its signature
    and location information. The qualified_name uniquely identifies the
    function within its module scope.

    Qualified Name Format:
        - Module function: "__module__.function_name"
        - Class method: "__module__.ClassName.method_name"
        - Nested class method: "__module__.OuterClass.InnerClass.method_name"
    """

    name: str  # Local function name (e.g., 'add')
    qualified_name: (
        QualifiedName  # Full name with complete scope hierarchy (e.g., '__module__.Calculator.add')
    )
    parameters: tuple[ParameterInfo, ...]  # All parameters in definition order
    has_return_annotation: bool  # Whether return type is annotated
    line_number: int  # Line where function is defined (1-indexed)
    file_path: Path  # Path to source file (as provided, can be absolute or relative)


@dataclass(frozen=True)
class CallCount:
    """Call count information for a function.

    Tracks how many times a function is called within the analyzed scope.
    Functions with zero calls are still included to distinguish between
    "not called" and "not found".
    """

    function_qualified_name: (
        QualifiedName  # Must match FunctionInfo.qualified_name exactly (e.g., "__module__.Calculator.add")
    )
    call_count: int  # Number of resolved calls (can be 0)


@dataclass(frozen=True)
class AnnotationScore:
    """Annotation completeness scores for a function.

    Scores represent how fully annotated a function is, used to identify
    functions that need type annotations. The total_score combines
    parameter and return scores with configurable weights.

    Special Cases:
        - Functions with no parameters get parameter_score = 1.0
        - 'self' and 'cls' parameters are excluded from scoring
    """

    function_qualified_name: (
        QualifiedName  # Identifies the scored function (e.g., "__module__.Calculator.add")
    )
    parameter_score: float  # Ratio of annotated parameters (0.0 to 1.0)
    return_score: float  # 1.0 if return annotated, 0.0 otherwise
    total_score: float  # Weighted combination (0.0 = no annotations, 1.0 = fully annotated)


@dataclass(frozen=True)
class FunctionPriority:
    """Complete priority analysis for a function.

    Combines all metrics to produce a final priority score for annotation.
    Higher scores indicate functions that should be prioritized for adding
    type annotations (frequently called but poorly annotated).
    """

    function_info: FunctionInfo  # Complete function metadata
    annotation_score: AnnotationScore  # Annotation completeness metrics
    call_count: int  # Number of times function is called
    priority_score: float  # Final priority for annotation (higher = more urgent)


@dataclass(frozen=True)
class UnresolvableCall:
    """Information about a call that couldn't be resolved.

    Provides context about calls the tool couldn't count,
    helping users understand coverage limitations.
    """

    line_number: int  # Line where the unresolvable call appears
    call_text: str  # First 50 chars of the call for context


@dataclass(frozen=True)
class ImportedName:
    """Represents an imported name and its source.

    Examples:
        import math -> ImportedName("math", "math", None, True, 0, "__module__")
        from typing import List -> ImportedName("List", "typing", None, False, 0, "__module__")
        import pandas as pd -> ImportedName("pd", "pandas", None, True, 0, "__module__")
        from ..utils import helper -> ImportedName("helper", "utils", None, False, 2, "__module__")
    """

    local_name: str  # Name used in this file (e.g., "pd", "sqrt", "List")
    source_module: str | None  # Module path (e.g., "pandas", "math", "typing"), None for relative
    original_name: str | None  # Original name if aliased (e.g., "DataFrame" for "as DataFrame")
    is_module_import: bool  # Distinguishes module imports from item imports (see below)
    relative_level: int  # 0 for absolute, 1 for ".", 2 for "..", etc.
    scope: QualifiedName  # Scope where import occurs (e.g., "__module__", "__module__.func")


@dataclass(frozen=True)
class AnalysisResult:
    """Complete result from analyzing a file.

    Contains both the prioritized functions and all calls that
    couldn't be resolved, providing full transparency.
    """

    priorities: tuple[FunctionPriority, ...]
    unresolvable_calls: tuple[UnresolvableCall, ...]
