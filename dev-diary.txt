9/12

got claude set up
got dev container running after a lot of back and forth
and more and more tweaks. but now i think it's good

my goodness, is it time to actually get started?

no :)
i'm forwarding 21 ports atm, they're accumulating more and more
ok fixed

ok let's get started i guess!

DONE add "even better toml" extension

tried to add a lint-on-edit hook but couldn't get it working, maybe someday - TODO

added pyright

added 100% coverage hook

update original plan to reflect progress from initial_implemenation_plan?
or don't, and just use both of those files when making the next plan?

TODO be sure to pick up the "future enhancement needed" note in commit 4 of initial_implementation_plan

TODO next up should be updating this to run on a _directory_ rather than a single file

DONE verify that we're treating self and cls correctly (they count as annotated)

DONE have a subagent for specifically dealing with linting / type-checking issues?

DONE update claude.md to talk about workspace/demo_files dir

DONE have a slash command for critically analyzing a plan file, looking for ways in which it's inconsistent with project goals, look for ways in which it's ambiguous / self-contradictory, generate detailed recommendations about any suggested changes

DONE have a slash command that reviews tests (with $arguments) and looks for duplicated / overly verbose code that can be improved by using helper functions

DONE use new /test-quality command

DONE count_function_calls() docstring is too brief - any others?

DONE add github action that runs pre-commit hooks on whole codebase

DONE figure out what to work on next!! probably the method call attribution bug, plan in pending/ dir!!

DONE read https://github.com/anthropics/claude-code-action?tab=readme-ov-file#-solutions--use-cases

===

9/13

NVM give claude.yml ability to run tests, right?
    oh i already did :)

DONE refactor dockerfile

ok i'm trying to actually understand how the ast module works

https://docs.python.org/3/library/ast.html#ast-helpers

i'm also having claude write up a doc in docs/guides/

https://docs.python.org/3/library/ast.html#ast.NodeVisitor

DONE add much more detailed docstrings to class, methods, and module of parser

DONE some kind of doc explaining what the current features / limitations are, etc?

===

9/14

DONE read ast guide doc

TODO someday investigate serena

DONE context7?

DONE try sequential thinking

DONE experiment more with suggesting that claude use subagents -- both for parallelism and for context efficiency

TODO investigate tdd guard

TODO figure out what to do about the unresolvable calls prereq. turn it into a project that we do first before continuing with scope work?

NOTE: when picking up the stuff in the appendixes (or really any of these plans), treat the code snippets as POTENTIAL STARTING POINTS FOR IDEATION, not actual cut-and-dry patterns that we definitely have to follow.

i really feel like TODO there's going to have to be some intermediate stage where i turn this high-level plan doc into several smaller implementation docs that each get handled one at a time.

===

9/15

reading https://github.com/CaptainCrouton89/.claude

interesting https://github.com/CaptainCrouton89/.claude/blob/main/output-styles/main.md

lol this is bad advice "Extreme Conciseness: Respond in 1-4 lines maximum. Terminal interfaces demand brevity—minimize tokens ruthlessly. Single word answers excel. Skip preambles, postambles, and explanations unless explicitly requested."

ok im not reading all this

ok reading https://github.com/jrheard/annotation_prioritizer/blob/main/docs/guides/ast-stdlib-module-guide.md

In [1]: import ast
   ...:
   ...: code = """
   ...: def regular_function(a: int, b=5, *args, **kwargs) -> str:
   ...:     '''A docstring'''
   ...:     return str(a + b)
   ...:
   ...: async def async_function(x: float) -> None:
   ...:     await some_operation(x)
   ...: """
   ...:
   ...: tree = ast.parse(code)

In [2]: print(tree)
<ast.Module object at 0xffff9cb91490>

In [3]: print(ast.dump(tree, indent=2))
Module(
  body=[
    FunctionDef(
      name='regular_function',
      args=arguments(
        args=[
          arg(
            arg='a',
            annotation=Name(id='int', ctx=Load())),
          arg(arg='b')],
        vararg=arg(arg='args'),
        kwarg=arg(arg='kwargs'),
        defaults=[
          Constant(value=5)]),
      body=[
        Expr(
          value=Constant(value='A docstring')),
        Return(
          value=Call(
            func=Name(id='str', ctx=Load()),
            args=[
              BinOp(
                left=Name(id='a', ctx=Load()),
                op=Add(),
                right=Name(id='b', ctx=Load()))]))],
      returns=Name(id='str', ctx=Load())),
    AsyncFunctionDef(
      name='async_function',
      args=arguments(
        args=[
          arg(
            arg='x',
            annotation=Name(id='float', ctx=Load()))]),
      body=[
        Expr(
          value=Await(
            value=Call(
              func=Name(id='some_operation', ctx=Load()),
              args=[
                Name(id='x', ctx=Load())])))],
      returns=Constant(value=None))])

having claude fill in these expanded parsed outputs for all of the examples

i think i'll also have it fill in the outputs of the nodevisitor examples

DONE have it rewrite this doc as a notebook???

TODO what about foo.bar.baz()?? look into that before starting work on the scoped plan

TODO what about super().foo()? not worth worrying about?

DONE split notebook into multiple smaller ones

DONE fix incorrect simple parentheses claim

===

9/16

DONE make the guide not mention scope-aware stuff, or the bug, etc

DONE add docs for the fields of each node type

ok now im reading the guide :)

DONE review all nodevisitors we have atm now that i actually understand this stuff..

definitely noticing a bug or two in doc 3
e.g. Calculator.result should actually be Calculator.add.result, but we're currently only using the function stack OR the class stack rather than both

kinda feels like need to properly interleave the function/class stack, or just like not have two separate stacks
tbh i'm not sure why we would have two separate stacks, seems to just make things worse

TODO write a similar guide for import tracking????

oh gosh
guide 3 is really interesting
note the bit about "module scope needs special handling because module-level variables are accessible from all functions"

for that matter, aren't _all_ variables in higher scopes accessible to all functions in inner scopes??

so it's not really that module needs special handling, it's that __module__ is the top-level parent,
and we always need to check all parents in order

ok so DONE make sure that __module__ (or the filename? like foo.py?) is always at the top of the scope tree

i think im gonna switch to the default model setting, of opus for 50% of usage limits
sonnet has been having some trouble with this docs stuff

oh wow this is useful https://github.com/Maciek-roboblog/Claude-Code-Usage-Monitor

ok getting there - starting doc 5...

interesting, note that args.defaults and args.kw_defaults are separate

ok so args.defaults is right-aligned with args
but args.kw_defaults has a one-to-one mapping with args.kwonlyargs

ok i started to review the scope plan doc, noticed that visit_FunctionDef wasn't checking keyword-only args, just args.args
so i'm beginning to learn :)

wow section 22 is actually really helpful, in file 5

anyway yeah at this point it's definitely clear to me that we should first do a pass on ClassDefs to figure out what classes exist in which files

rather than this "if the first letter is uppercase it's a class" business

ok i'm gonna get lunch
let's pick up section 24 when i get back

NOTE: we should _definitely_ actually stay in single-file mode for a while longer

ok lol doc 6 just contained a dupe of section 24

removing it

ok i guess i know ast stuff now!!

ok
let's review our visitors

yeah i kinda feel like we should do inheritance _before_ multi file? not sure

yeah so in functionparser we're doing class_stack
i think we should do .scope_stack
which is a list of Scope, which has fields name and kind, where kind is an enum

ok i'm having it do that
this will probably interfere with the scope-aware doc but so be it

DONE also do this in call_counter

DONE instead of taking call_counts, CallCountVisitor should take known_functions - less confusing
ie a list/tuple of FunctionInfos

hm, one interesting note is that subagents appear to default to sonnet
i bet i could have it use opus in subagents in cases where i really care about that (eg complex plan manipulation?)

NVM call_counter currently special-cases `self` - should we also special-case `cls`?
should we add just-in-case sanity checks to verify that these special-cases are appropriate / aren't being false positives on pathological code?
or just leave a to-do comment and move on?

maybe an /opus-agent command would be useful someday?

DONE figure out how to deduplicate between call_counter and function_parser

nvm:

● After analyzing both files and thinking through the implications, I recommend keeping the current duplication. Here's why:

  The Duplication is Minimal and Beneficial

  The scope stack logic is nearly identical between the files - about 15-20 lines of simple push/pop operations. However, this duplication is actually good because:

  1. Different purposes: function_parser builds qualified names once per function definition, while call_counter resolves calls repeatedly with complex filtering logic (e.g., excluding function scopes for self.method() calls)
  2. Future divergence: According to the project status, call_counter will soon need scope-aware variable tracking to fix the instance method bug. This will make its scope tracking significantly more complex, while function_parser
  will remain simple.
  3. Project principles: The codebase avoids inheritance unless absolutely necessary. Creating a base class would violate this principle for minimal benefit.
  4. Simplicity: Each visitor is self-contained and easy to understand. The duplication is trivial (just AST traversal boilerplate), while the unique logic in each file is complex and different.

  Alternative Considered but Rejected

  I considered extracting a ScopeTracker helper class, but this would add unnecessary abstraction for such simple code that's going to diverge anyway when variable tracking is implemented.

  Conclusion

  The current design is clean and appropriate. The "duplication" is really just standard AST visitor boilerplate that keeps each module focused on its specific responsibility. No changes recommended.

ok i think it's time to revisit the scope-aware doc

omg wow: using opus, telling it to ask me questions, and telling it to use sequential thinking = good results!!!

ok i added a new `opus-agent` general-purpose agent
this seems to work!!

NOTE: i don't think sub-agents get the full conversation history, so i need to have it prompt them with lots of context
i'll add more about this to the description field of the agent

TODO use /review-plan on each of these new docs

gosh
these new docs are not perfect :/

the prompts we used to generate them were too brief

i'm tempted to rewind to that conversation and do it again

gonna stash my changes for now

ok this is much better :)

TODO use /review-plan on each of these new docs

TODO think about when to implement import support. should we do this before or after "scope-aware" variable resolution?

TODO is there any way to simplify / condense _resolve_class_name and _resolve_compound_class_name?

TODO make sure test filenames match the prod filenames; add this to claude.md

ok man i am way down into a rabbit hole

LESSON LEARNED: SERIOUSLY ONLY LET IT DO ONE COMMIT AT A TIME