9/12

got claude set up
got dev container running after a lot of back and forth
and more and more tweaks. but now i think it's good

my goodness, is it time to actually get started?

no :)
i'm forwarding 21 ports atm, they're accumulating more and more
ok fixed

ok let's get started i guess!

DONE add "even better toml" extension

tried to add a lint-on-edit hook but couldn't get it working, maybe someday - TODO

added pyright

added 100% coverage hook

update original plan to reflect progress from initial_implemenation_plan?
or don't, and just use both of those files when making the next plan?

TODO be sure to pick up the "future enhancement needed" note in commit 4 of initial_implementation_plan

TODO next up should be updating this to run on a _directory_ rather than a single file

DONE verify that we're treating self and cls correctly (they count as annotated)

DONE have a subagent for specifically dealing with linting / type-checking issues?

DONE update claude.md to talk about workspace/demo_files dir

DONE have a slash command for critically analyzing a plan file, looking for ways in which it's inconsistent with project goals, look for ways in which it's ambiguous / self-contradictory, generate detailed recommendations about any suggested changes

DONE have a slash command that reviews tests (with $arguments) and looks for duplicated / overly verbose code that can be improved by using helper functions

DONE use new /test-quality command

DONE count_function_calls() docstring is too brief - any others?

DONE add github action that runs pre-commit hooks on whole codebase

DONE figure out what to work on next!! probably the method call attribution bug, plan in pending/ dir!!

DONE read https://github.com/anthropics/claude-code-action?tab=readme-ov-file#-solutions--use-cases

===

9/13

NVM give claude.yml ability to run tests, right?
    oh i already did :)

DONE refactor dockerfile

ok i'm trying to actually understand how the ast module works

https://docs.python.org/3/library/ast.html#ast-helpers

i'm also having claude write up a doc in docs/guides/

https://docs.python.org/3/library/ast.html#ast.NodeVisitor

DONE add much more detailed docstrings to class, methods, and module of parser

DONE some kind of doc explaining what the current features / limitations are, etc?

===

9/14

DONE read ast guide doc

TODO someday investigate serena

DONE context7?

DONE try sequential thinking

DONE experiment more with suggesting that claude use subagents -- both for parallelism and for context efficiency

TODO investigate tdd guard

DONE figure out what to do about the unresolvable calls prereq. turn it into a project that we do first before continuing with scope work?

NOTE: when picking up the stuff in the appendixes (or really any of these plans), treat the code snippets as POTENTIAL STARTING POINTS FOR IDEATION, not actual cut-and-dry patterns that we definitely have to follow.

i really feel like DONE there's going to have to be some intermediate stage where i turn this high-level plan doc into several smaller implementation docs that each get handled one at a time.

===

9/15

reading https://github.com/CaptainCrouton89/.claude

interesting https://github.com/CaptainCrouton89/.claude/blob/main/output-styles/main.md

lol this is bad advice "Extreme Conciseness: Respond in 1-4 lines maximum. Terminal interfaces demand brevityâ€”minimize tokens ruthlessly. Single word answers excel. Skip preambles, postambles, and explanations unless explicitly requested."

ok im not reading all this

ok reading https://github.com/jrheard/annotation_prioritizer/blob/main/docs/guides/ast-stdlib-module-guide.md

In [1]: import ast
   ...:
   ...: code = """
   ...: def regular_function(a: int, b=5, *args, **kwargs) -> str:
   ...:     '''A docstring'''
   ...:     return str(a + b)
   ...:
   ...: async def async_function(x: float) -> None:
   ...:     await some_operation(x)
   ...: """
   ...:
   ...: tree = ast.parse(code)

In [2]: print(tree)
<ast.Module object at 0xffff9cb91490>

In [3]: print(ast.dump(tree, indent=2))
Module(
  body=[
    FunctionDef(
      name='regular_function',
      args=arguments(
        args=[
          arg(
            arg='a',
            annotation=Name(id='int', ctx=Load())),
          arg(arg='b')],
        vararg=arg(arg='args'),
        kwarg=arg(arg='kwargs'),
        defaults=[
          Constant(value=5)]),
      body=[
        Expr(
          value=Constant(value='A docstring')),
        Return(
          value=Call(
            func=Name(id='str', ctx=Load()),
            args=[
              BinOp(
                left=Name(id='a', ctx=Load()),
                op=Add(),
                right=Name(id='b', ctx=Load()))]))],
      returns=Name(id='str', ctx=Load())),
    AsyncFunctionDef(
      name='async_function',
      args=arguments(
        args=[
          arg(
            arg='x',
            annotation=Name(id='float', ctx=Load()))]),
      body=[
        Expr(
          value=Await(
            value=Call(
              func=Name(id='some_operation', ctx=Load()),
              args=[
                Name(id='x', ctx=Load())])))],
      returns=Constant(value=None))])

having claude fill in these expanded parsed outputs for all of the examples

i think i'll also have it fill in the outputs of the nodevisitor examples

DONE have it rewrite this doc as a notebook???

TODO what about foo.bar.baz()?? look into that before starting work on the scoped plan

TODO what about super().foo()? not worth worrying about?

DONE split notebook into multiple smaller ones

DONE fix incorrect simple parentheses claim

===

9/16

DONE make the guide not mention scope-aware stuff, or the bug, etc

DONE add docs for the fields of each node type

ok now im reading the guide :)

DONE review all nodevisitors we have atm now that i actually understand this stuff..

definitely noticing a bug or two in doc 3
e.g. Calculator.result should actually be Calculator.add.result, but we're currently only using the function stack OR the class stack rather than both

kinda feels like need to properly interleave the function/class stack, or just like not have two separate stacks
tbh i'm not sure why we would have two separate stacks, seems to just make things worse

TODO write a similar guide for import tracking????

oh gosh
guide 3 is really interesting
note the bit about "module scope needs special handling because module-level variables are accessible from all functions"

for that matter, aren't _all_ variables in higher scopes accessible to all functions in inner scopes??

so it's not really that module needs special handling, it's that __module__ is the top-level parent,
and we always need to check all parents in order

ok so DONE make sure that __module__ (or the filename? like foo.py?) is always at the top of the scope tree

i think im gonna switch to the default model setting, of opus for 50% of usage limits
sonnet has been having some trouble with this docs stuff

oh wow this is useful https://github.com/Maciek-roboblog/Claude-Code-Usage-Monitor

ok getting there - starting doc 5...

interesting, note that args.defaults and args.kw_defaults are separate

ok so args.defaults is right-aligned with args
but args.kw_defaults has a one-to-one mapping with args.kwonlyargs

ok i started to review the scope plan doc, noticed that visit_FunctionDef wasn't checking keyword-only args, just args.args
so i'm beginning to learn :)

wow section 22 is actually really helpful, in file 5

anyway yeah at this point it's definitely clear to me that we should first do a pass on ClassDefs to figure out what classes exist in which files

rather than this "if the first letter is uppercase it's a class" business

ok i'm gonna get lunch
let's pick up section 24 when i get back

NOTE: we should _definitely_ actually stay in single-file mode for a while longer

ok lol doc 6 just contained a dupe of section 24

removing it

ok i guess i know ast stuff now!!

ok
let's review our visitors

yeah i kinda feel like we should do inheritance _before_ multi file? not sure

yeah so in functionparser we're doing class_stack
i think we should do .scope_stack
which is a list of Scope, which has fields name and kind, where kind is an enum

ok i'm having it do that
this will probably interfere with the scope-aware doc but so be it

DONE also do this in call_counter

DONE instead of taking call_counts, CallCountVisitor should take known_functions - less confusing
ie a list/tuple of FunctionInfos

hm, one interesting note is that subagents appear to default to sonnet
i bet i could have it use opus in subagents in cases where i really care about that (eg complex plan manipulation?)

NVM call_counter currently special-cases `self` - should we also special-case `cls`?
should we add just-in-case sanity checks to verify that these special-cases are appropriate / aren't being false positives on pathological code?
or just leave a to-do comment and move on?

maybe an /opus-agent command would be useful someday?

DONE figure out how to deduplicate between call_counter and function_parser

nvm:

â— After analyzing both files and thinking through the implications, I recommend keeping the current duplication. Here's why:

  The Duplication is Minimal and Beneficial

  The scope stack logic is nearly identical between the files - about 15-20 lines of simple push/pop operations. However, this duplication is actually good because:

  1. Different purposes: function_parser builds qualified names once per function definition, while call_counter resolves calls repeatedly with complex filtering logic (e.g., excluding function scopes for self.method() calls)
  2. Future divergence: According to the project status, call_counter will soon need scope-aware variable tracking to fix the instance method bug. This will make its scope tracking significantly more complex, while function_parser
  will remain simple.
  3. Project principles: The codebase avoids inheritance unless absolutely necessary. Creating a base class would violate this principle for minimal benefit.
  4. Simplicity: Each visitor is self-contained and easy to understand. The duplication is trivial (just AST traversal boilerplate), while the unique logic in each file is complex and different.

  Alternative Considered but Rejected

  I considered extracting a ScopeTracker helper class, but this would add unnecessary abstraction for such simple code that's going to diverge anyway when variable tracking is implemented.

  Conclusion

  The current design is clean and appropriate. The "duplication" is really just standard AST visitor boilerplate that keeps each module focused on its specific responsibility. No changes recommended.

ok i think it's time to revisit the scope-aware doc

omg wow: using opus, telling it to ask me questions, and telling it to use sequential thinking = good results!!!

ok i added a new `opus-agent` general-purpose agent
this seems to work!!

NOTE: i don't think sub-agents get the full conversation history, so i need to have it prompt them with lots of context
i'll add more about this to the description field of the agent

DONE use /review-plan on each of these new docs

gosh
these new docs are not perfect :/

the prompts we used to generate them were too brief

i'm tempted to rewind to that conversation and do it again

gonna stash my changes for now

ok this is much better :)

DONE use /review-plan on each of these new docs

DONE think about when to implement import support. should we do this before or after "scope-aware" variable resolution?

DONE is there any way to simplify / condense _resolve_class_name and _resolve_compound_class_name?

TODO make sure test filenames match the prod filenames; add this to claude.md

ok man i am way down into a rabbit hole

LESSON LEARNED: SERIOUSLY ONLY LET IT DO ONE COMMIT AT A TIME

TODO i feel like the code in count_function_calls() is duplicated in multiple places

TODO add asserts in some places where we currently have to-dos??

DONE QualifiedName newtype?? could be useful for prod AND test code???

DONE resolve_function_call and resolve_class_name are identical

TODO helper for making a qualified name from a scope stack?

hm apparently the "class improvements" plan is done now??

 ======================================================================
     Testing False Positive Elimination (Constants not treated as classes)
     ======================================================================

     Discovered classes: frozenset({'__module__.RealClass', '__module__.AnotherClass'})

     --------------------------------------------------
     Testing constants (should NOT be classes):
     --------------------------------------------------
       MAX_SIZE                  -> âœ“ Correctly ignored
       DEFAULT_CONFIG            -> âœ“ Correctly ignored
       PI                        -> âœ“ Correctly ignored
       EMPTY_LIST                -> âœ“ Correctly ignored
       NULL_VALUE                -> âœ“ Correctly ignored
       CONNECTION_TIMEOUT        -> âœ“ Correctly ignored
       ERROR_MESSAGE             -> âœ“ Correctly ignored
       CONSTANT_IN_CLASS         -> âœ“ Correctly ignored

     --------------------------------------------------
     Testing actual classes (should BE classes):
     --------------------------------------------------
       RealClass                 -> âœ“ Correctly identified
       AnotherClass              -> âœ“ Correctly identified

     ======================================================================
     âœ… SUCCESS: No false positives! Constants correctly ignored.
     ======================================================================
     Bash(cd /workspace/debug_verification && python test_non_pep8_classes.py)
     Waitingâ€¦
     ======================================================================
     Testing Non-PEP8 Class Name Recognition
     ======================================================================

     Discovered classes (11 total):
       - __module__.AnotherStandardClass
       - __module__.HTTP404Handler
       - __module__.Parser2
       - __module__.SINGLETON
       - __module__.StandardClass
       - __module__._InternalClass
       - __module__.dataProcessor
       - __module__.htmlRenderer
       - __module__.requestHandler
       - __module__.x
       - __module__.xmlParser

     ----------------------------------------------------------------------
     Testing class recognition:
     ----------------------------------------------------------------------
       xmlParser            (Non-PEP8: lowercase start     ) -> âœ“ Recognized
       dataProcessor        (Non-PEP8: camelCase           ) -> âœ“ Recognized
       htmlRenderer         (Non-PEP8: lowercase start     ) -> âœ“ Recognized
       requestHandler       (Non-PEP8: camelCase           ) -> âœ“ Recognized
       x                    (Non-PEP8: single letter       ) -> âœ“ Recognized
       _InternalClass       (Non-PEP8: underscore prefix   ) -> âœ“ Recognized
       SINGLETON            (Non-PEP8: all uppercase       ) -> âœ“ Recognized
       Parser2              (With number                   ) -> âœ“ Recognized
       HTTP404Handler       (Mixed case with numbers       ) -> âœ“ Recognized
       StandardClass        (PEP8: PascalCase              ) -> âœ“ Recognized
       AnotherStandardClass (PEP8: PascalCase              ) -> âœ“ Recognized

     ======================================================================
     âœ… SUCCESS: All class names recognized, regardless of naming convention!
     ======================================================================
     Bash(cd /workspace/debug_verification && python test_nested_classes.py)
     Waitingâ€¦
     ======================================================================
     Testing Nested Class Detection
     ======================================================================

     Discovered classes (19 total):
       - __module__.ComplexOuter
       - __module__.ComplexOuter.StaticNested
       - __module__.ComplexOuter.method_with_class.MethodClass
       - __module__.ComplexOuter.method_with_class.MethodClass.DoublyNested
       - __module__.Container
       - __module__.Container.First
       - __module__.Container.Second
       - __module__.Container.Third
       - __module__.Container.Third.Nested
       - __module__.Level1
       - __module__.Level1.Level2
       - __module__.Level1.Level2.Level3
       - __module__.Level1.Level2.Level3.Level4
       - __module__.Outer
       - __module__.Outer.Inner
       - __module__.WithMethod
       - __module__.WithMethod.create_class.MethodLocalClass
       - __module__.async_factory.AsyncLocalClass
       - __module__.factory_function.LocalClass

     ----------------------------------------------------------------------
     Testing nested class recognition:
     ----------------------------------------------------------------------
       Outer                                                   -> âœ“ Found
       Outer.Inner                                             -> âœ“ Found
       Level1                                                  -> âœ“ Found
       Level1.Level2                                           -> âœ“ Found
       Level1.Level2.Level3                                    -> âœ“ Found
       Level1.Level2.Level3.Level4                             -> âœ“ Found
       Container                                               -> âœ“ Found
       Container.First                                         -> âœ“ Found
       Container.Second                                        -> âœ“ Found
       Container.Third                                         -> âœ“ Found
       Container.Third.Nested                                  -> âœ“ Found
       factory_function.LocalClass                             -> âœ“ Found
       async_factory.AsyncLocalClass                           -> âœ“ Found
       WithMethod                                              -> âœ“ Found
       WithMethod.create_class.MethodLocalClass                -> âœ“ Found
       ComplexOuter                                            -> âœ“ Found
       ComplexOuter.method_with_class.MethodClass              -> âœ“ Found
       ComplexOuter.method_with_class.MethodClass.DoublyNested -> âœ“ Found
       ComplexOuter.StaticNested                               -> âœ“ Found

     ----------------------------------------------------------------------
     Checking for unexpected classes:
     ----------------------------------------------------------------------
       âœ“ No unexpected classes found

     ======================================================================
     âœ… SUCCESS: All nested classes correctly detected!
     ======================================================================
     Bash(cd /workspace/debug_verification && python test_builtin_tracking.py)
     Waitingâ€¦
     ======================================================================
     Testing Builtin Type Tracking (should NOT be tracked)
     ======================================================================

     Discovered classes (2 total):
       - __module__.AnotherUserClass
       - __module__.UserClass

     ----------------------------------------------------------------------
     Testing builtin types (should NOT be in registry):
     ----------------------------------------------------------------------
       int             -> âœ“ Correctly excluded
       str             -> âœ“ Correctly excluded
       list            -> âœ“ Correctly excluded
       dict            -> âœ“ Correctly excluded
       set             -> âœ“ Correctly excluded
       tuple           -> âœ“ Correctly excluded
       bool            -> âœ“ Correctly excluded
       float           -> âœ“ Correctly excluded
       bytes           -> âœ“ Correctly excluded
       bytearray       -> âœ“ Correctly excluded
       complex         -> âœ“ Correctly excluded
       frozenset       -> âœ“ Correctly excluded
       memoryview      -> âœ“ Correctly excluded
       range           -> âœ“ Correctly excluded
       slice           -> âœ“ Correctly excluded
       object          -> âœ“ Correctly excluded
       type            -> âœ“ Correctly excluded
       Exception       -> âœ“ Correctly excluded
       BaseException   -> âœ“ Correctly excluded

     ----------------------------------------------------------------------
     Testing user classes (should BE in registry):
     ----------------------------------------------------------------------
       UserClass            -> âœ“ Correctly tracked
       AnotherUserClass     -> âœ“ Correctly tracked

     ----------------------------------------------------------------------
     Registry contents verification:
     ----------------------------------------------------------------------
       âœ“ Registry contains exactly the expected user classes

     ======================================================================
     âœ… SUCCESS: Builtins correctly excluded, only user classes tracked!
     ======================================================================
     Bash(cd /workspace/debug_verification && python test_instance_limitation.py)
     Waitingâ€¦
     ======================================================================
     Testing Instance Method Call Limitation
     ======================================================================

     This test verifies the KNOWN LIMITATION that instance method
     calls via variables are NOT counted (as documented in the plan).

     ----------------------------------------------------------------------
     Call counts for all discovered functions:
     ----------------------------------------------------------------------
       __module__.Calculator.add                          : 1 calls
       __module__.Calculator.create                       : 2 calls
       __module__.Calculator.multiply                     : 1 calls
       __module__.Calculator.validate                     : 1 calls
       __module__.Processor.process                       : 1 calls
       __module__.test_class_method_calls                 : 0 calls
       __module__.test_instance_method_calls              : 0 calls
       __module__.test_self_method_calls                  : 0 calls
       __module__.test_self_method_calls.InternalTest.method_a : 0 calls
       __module__.test_self_method_calls.InternalTest.method_b : 0 calls

     ----------------------------------------------------------------------
     Verification of expected behavior:
     ----------------------------------------------------------------------
       __module__.Calculator.add                     -> âœ“ Has calls
         (Direct class method call)
       __module__.Calculator.multiply                -> âœ“ Has calls
         (Direct class method call)
       __module__.Calculator.create                  -> âœ“ Has calls
         (Class method call)
       __module__.Calculator.validate                -> âœ“ Has calls
         (Static method call)
       __module__.Processor.process                  -> âœ“ Has calls
         (Direct class method call)

     ----------------------------------------------------------------------
     Detailed count verification:
     ----------------------------------------------------------------------
       Calculator.add: 1 calls
         - Expected: 1 (from Calculator.add(None, 5, 3) in test_class_method_calls)
         - NOT counted: calc.add() calls in test_instance_method_calls
         âœ“ Correct: Only direct class calls counted

     ======================================================================
     âœ… SUCCESS: Instance method limitation working as documented!
        - Direct class method calls ARE counted
        - Instance variable method calls are NOT counted
        - This is a known limitation pending variable tracking feature
     ======================================================================

i mean i guess it makes sense - we now have a class registry
instead of just guessing based on isupper

 ================================================================================
     CLASS DETECTION VERIFICATION SUMMARY
     ================================================================================

     Verifying implementation against claims in:
       /workspace/plans/completed/class-detection-improvements-2025-09-16.md

     --------------------------------------------------------------------------------
     RUNNING VERIFICATION TESTS
     --------------------------------------------------------------------------------

     ðŸ“ False Positive Elimination...
        âœ… PASSED
        â†’ âœ… SUCCESS: No false positives! Constants correctly ignored.

     ðŸ“ Non-PEP8 Class Recognition...
        âœ… PASSED
        â†’ âœ… SUCCESS: All class names recognized, regardless of naming convention!

     ðŸ“ Nested Class Support...
        âœ… PASSED
        â†’ âœ… SUCCESS: All nested classes correctly detected!

     ðŸ“ Builtin Exclusion...
        âœ… PASSED
        â†’ âœ… SUCCESS: Builtins correctly excluded, only user classes tracked!

     ðŸ“ Instance Method Limitation...
        âœ… PASSED
        â†’ âœ… SUCCESS: Instance method limitation working as documented!

     ðŸ“ QualifiedName Type Usage...
        âœ… PASSED
        â†’ âœ… SUCCESS: QualifiedName type is properly used throughout!

     ðŸ“ End-to-End Integration...
        âœ… PASSED
        â†’ âœ… SUCCESS: All integration tests passed!

     ================================================================================
     VERIFICATION RESULTS AGAINST PLAN CLAIMS
     ================================================================================

     Claim Verification:
       âœ… ClassRegistry tracks only user-defined classes                    [VERIFIED]
       âœ… ClassDiscoveryVisitor finds all ClassDef nodes                    [VERIFIED]
       âœ… No False Positives - constants NOT treated as classes             [VERIFIED]
       âœ… Non-PEP8 class names ARE recognized (xmlParser, etc.)             [VERIFIED]
       âœ… Nested classes supported (Outer.Inner.method patterns)            [VERIFIED]
       âœ… QualifiedName type used throughout                                [VERIFIED]
       âœ… Builtins (int, str, etc.) NOT tracked                             [VERIFIED]
       âœ… Instance method calls NOT counted (documented limitation)         [VERIFIED]

     --------------------------------------------------------------------------------
     IMPLEMENTATION DETAILS CONFIRMED
     --------------------------------------------------------------------------------
       â€¢ ClassRegistry uses frozenset[QualifiedName] for immutability
       â€¢ ClassDiscoveryVisitor correctly handles scope stacking
       â€¢ CallCountVisitor accepts ClassRegistry parameter (breaking API change)
       â€¢ Classes in functions are tracked (e.g., factory.LocalClass)
       â€¢ Self/cls method calls properly resolved within classes
       â€¢ Forward references in type annotations handled
       â€¢ 100% test coverage maintained (per existing tests)

     --------------------------------------------------------------------------------
     KNOWN LIMITATIONS (AS DOCUMENTED)
     --------------------------------------------------------------------------------
       â€¢ Instance method calls via variables not counted (calc.add())
       â€¢ Imported classes not tracked (requires import resolution)
       â€¢ No support for @property methods yet
       â€¢ No support for type aliases or generic classes
       â€¢ No cross-module call tracking

     ================================================================================
     FINAL VERDICT
     ================================================================================

     âœ… IMPLEMENTATION FULLY MATCHES PLAN CLAIMS

     All features described in the plan document have been successfully
     implemented and verified through comprehensive testing:

       1. False positives eliminated (constants no longer treated as classes)
       2. Non-PEP8 class names correctly identified
       3. Full nested class support including classes in functions
       4. QualifiedName type used for type safety
       5. Builtins excluded from tracking
       6. Instance method limitation properly documented and working as expected

     The implementation is production-ready and provides a solid foundation
     for future enhancements like variable tracking and import resolution.
     ================================================================================

lol production-ready

wow it wrote up a report and everything
that's actually neat
spawning a subagent to verify stuff is useful!

ok then
what next? unresolvability?

ok DONE start on unresolvability

TODO update project_status doc

===

9/18

TODO investigate https://www.augmentcode.com/ ?

DONE why only hold onto 5 unresolvable examples? let's keep them all for now and limit later if needed

DONE remove categorization entirely for now

DONE remove optional flag, just have this be always-on for now

NVM the unresolvability plan is getting complicated. what features can we cut now and add later if needed?

DONE update /make-plan to first give me a bulleted outline for confirmation before writing the md file

NVM tomorrow regenerate a new plan file for unresolvability - simple stuff, no categorization, no flag
although need to figure out what we'll do re: capturing the original text of the call - use that ast function?

omg lol it implemented the plan...

===

9/19

TODO consider experimenting with the agents in the appendix of https://zachwills.net/how-to-use-claude-code-subagents-to-parallelize-development/

DONE refactor test_unresolvable_call_text_extraction_edge_cases() test

i had claude look into ty

# ty Type Checker Evaluation Report

**Date:** September 19, 2025
**Project:** annotation-prioritizer
**ty Version:** 0.0.1-alpha.21
**pyright Version:** 1.1.383

## Executive Summary

This document presents a comprehensive evaluation of Astral's `ty` type checker on the annotation-prioritizer codebase, comparing it against the currently used pyright in strict mode. ty is a preview release Rust-based type checker claiming 1-2 orders of magnitude performance improvements over existing Python type checkers.

### Key Findings

- **Performance:** ty is approximately **15x faster** than pyright (70ms vs 1100ms)
- **Maturity:** ty found 9 errors that pyright didn't catch, but all were false positives
- **Compatibility:** ty currently checks files that pyright intentionally excludes (Jupyter notebooks, which are in docs/)
- **Stability:** No crashes encountered, but exit code 1 even when no actionable errors in src/
- **Python 3.13:** Surprisingly lenient with new syntax features, potentially missing real issues

## Installation Process

Installation was straightforward using uvx (Astral's tool runner):

```bash
uvx ty --version
```

The tool automatically downloaded and installed on first use (7.9MB download, installed in 7ms). No configuration file support yet - ty auto-detects the virtual environment.

## Performance Metrics

### Execution Time Comparison

| Directory | pyright | ty | Speedup |
|-----------|---------|-----|---------|
| Full project | 1.122s | 0.073s | 15.4x |
| src/ only | 1.077s | 0.070s | 15.4x |
| tests/ only | ~1.1s | ~0.07s | ~15x |

ty consistently delivers on its performance promise, executing 15x faster than pyright across all test scenarios.

## Error Detection Analysis

### Overall Error Counts

| Checker | Total Errors | Exit Code |
|---------|--------------|-----------|
| pyright | 0 | 0 |
| ty | 9 | 1 |

### ty's Reported Errors (All False Positives)

All 9 errors were `unresolved-attribute` type errors in:

1. **Jupyter Notebooks (5 errors):**
   - `docs/guides/ast-stdlib-module/4-ast-debugging-tools.ipynb`: 3 errors
   - `docs/guides/ast-stdlib-module/5-ast-best-practices.ipynb`: 2 errors
   - Issue: Incorrectly typing `ast.parse().body[0]` as generic `stmt` instead of specific node types

2. **Test Files (4 errors):**
   - `tests/unit/test_cli.py`: 4 errors about `exc_info.value.code`
   - Issue: Not recognizing `SystemExit` has a `code` attribute when caught via pytest

### False Positive Examples

```python
# ty thinks body[0] is generic stmt, not recognizing it could be Expr
ast.parse("module.sub.func").body[0].value  # ty: error[unresolved-attribute]

# ty doesn't recognize SystemExit.code attribute
with pytest.raises(SystemExit) as exc_info:
    main()
assert exc_info.value.code == 1  # ty: error[unresolved-attribute]
```

## Edge Case Testing Results

| Test Case | pyright | ty | Agreement | Notes |
|-----------|---------|-----|-----------|-------|
| Frozen Dataclasses | âœ“ | âœ“ | Yes | Both handle correctly |
| Python 3.13 Features | âœ— | âœ“ | No | pyright more strict on PEP 695 |
| AST Visitor Pattern | âœ— | âœ“ | No | pyright enforces superCall |
| Complex Type Annotations | âœ— | âœ“ | No | ty more permissive |
| Pytest Fixtures | âœ“ | âœ“ | Yes | Both handle correctly |

### Notable Differences

1. **PEP 695 Generic Syntax:** ty accepts new Python 3.13 syntax without issues, while pyright enforces additional checks
2. **AST Visitor Methods:** Both handle the N802 exemption for `visit_*` methods correctly
3. **Type Inference:** ty appears more permissive, potentially missing legitimate type errors

## File Coverage Differences

- **pyright:** Respects `pyrightconfig.json` exclusions (demo_files/, Jupyter notebooks)
- **ty:** Checks all Python-like files, including notebooks and excluded directories

This difference accounts for most of ty's reported errors - it's checking files that pyright intentionally skips.

## Configuration and Ecosystem

### Current Limitations

1. **No configuration file support:** Cannot exclude directories or set strictness levels
2. **No JSON output:** Makes programmatic integration challenging
3. **Limited rule documentation:** Difficult to understand what each rule checks
4. **No inline suppressions:** Cannot disable specific checks for known false positives

### Virtual Environment Detection

ty successfully auto-detected the `.venv` directory without configuration, which is convenient for standard setups.

## Assessment for This Codebase

### Strengths
- **Exceptional performance:** 15x speedup is significant for large codebases
- **Zero configuration start:** Works out of the box
- **No crashes:** Stable despite alpha status

### Weaknesses
- **False positives:** All 9 errors were incorrect
- **Too permissive:** Passes tests that pyright correctly fails
- **No configuration:** Cannot exclude docs/ or tune behavior
- **Limited maturity:** ~15% conformance vs pyright's near 100%

### Current Readiness: **Not Ready**

ty is not ready to replace pyright for this project because:

1. **Accuracy Issues:** False positives and missed real errors
2. **Configuration Gap:** Cannot exclude documentation files
3. **Integration Challenges:** No JSON output for tooling
4. **Maturity Gap:** Too early in development cycle

## Recommendations

### Immediate Actions
1. **Continue with pyright** as the primary type checker
2. **Do not integrate ty** into the build pipeline
3. **Document this evaluation** for future reference

### Future Monitoring
1. **Re-evaluate ty** when it reaches beta or 0.1.0
2. **Watch for:** Configuration file support, improved accuracy, rule documentation
3. **Performance benefits** will be valuable once accuracy improves

### Potential Future Use Cases
When ty matures, it could serve as:
- Quick sanity check in pre-commit hooks (speed advantage)
- Secondary checker for different perspective
- Performance solution for very large codebases

## Script and Tool Additions

Created tools for ongoing ty evaluation:

1. **`scripts/compare_type_checkers.py`**: Comprehensive comparison tool
2. **`scripts/test_ty_edge_cases.py`**: Edge case testing suite
3. **Raw output artifacts**: Saved in `scripts/type_checker_outputs/`

These can be re-run periodically to track ty's progress toward production readiness.

## Conclusion

While ty shows impressive performance gains and stability for an alpha release, it lacks the accuracy and configurability required for production use on this codebase. The 15x speed improvement is compelling, but not at the cost of false positives and missed real issues.

The project should continue using pyright while monitoring ty's development. Once ty reaches greater maturity (likely 0.5+ based on typical Astral release patterns), it will be worth re-evaluating for potential adoption or parallel use.

ok
what next

added /update-project-status

ok, looking through v3 of the scope-tracking doc
very interesting - looks like there's some simlar logic shared across call_counter and variabletracker

DONE rename VariableTracker to VariableTrackingVisitor

DONE review-plan

TODO keep an eye on "explicitly deferred features" section in scope-tracking

DONE update call_counter to ignore builtin functions

DONE see if anything in scope_tracker.py can be cleaned up / simplified / refactored
also someday i'll definitely have to make this be a list that gets mutated in-place :p but can save that for after profiling

DONE pick up scope-tracking doc

DONE we sure say that we do a "two-pass analysis" a bunch of times. tbh i think we do like four passes. which is fine but we should be more clear in docs
    DONE update count_function_calls() and variable_discovery.py to be more clear about this

DONE in visit_FunctionDef is `node.args.args` sufficient?
    no
    DONE can we get a utility function for this? returns an iterable of (name, type)?
    i could swear that we need to iterate over .args and friends in multiple places - eg functionparser?

    DONE write a test that would have failed if we had only done `node.args.args`

DONE isn't there a ruff rule that prohibits bare `# pyright: ignore` comments with no associated error code? doesn't seem enabled?

DONE update docstring to make it clear that you're supposed to call .get_registry() on the visitor after it visits

DONE look into this (make a github issue for it to investigate someday?):
    - Discovered limitation: Class reference pattern (`CalcClass = Calculator; calc = CalcClass()`)
    doesn't work - the instantiation via variable holding a class reference is not tracked

    had claude make an issue for it!

also gonna have claude make an issue for our unit vs integration tests - doesn't seem like we're being consistent about this

===

9/23

DONE update propose-plan to be aggressive about looking for ways to reuse pre-existing helper code
  also have it recommend any relevant prerequisite refactors that should be done up-front to make the proposed changes easier to implement

DONE tell code review prompt to ignore dev-diary.txt

TICKETED see if we can deduplicate the places where we make qualified names from a scope

DONE decide whether or not to actually implement https://github.com/jrheard/annotation_prioritizer/issues/21 - maybe it's fine as-is?

having claude add some hooks

oh fun - note that hooks don't get run for subagents

DONE anything else in claude.md that should be moved to hooks?

ok!
did a bunch of good stuff

what next?

DONE look into https://github.com/jrheard/annotation_prioritizer/issues/21

and then DONE look into https://github.com/jrheard/annotation_prioritizer/issues/22

i'm trying wording like "investigate XYZ then present your findings", rather than "do you think X is too Y?" - seems to help?
  might be placebo, no clue

DONE can we make our claude hooks more targeted? at the very least, the commit message one?

DONE _build_qualified_name() in function_parser seems pretty verbose now - should we remove it? are there any other similar functions/methods in other files that are just super verbose with no real value?

DONE /review-plan on the init doc

===

9/24

NVM also think about htis:

      ALTERNATIVE APPROACHES:

  Simpler Solution: Track class instantiations without synthetic methods:
  - When encountering Calculator(), check if it's a known class
  - If yes, check if Calculator.__init__ exists in known functions
  - Count toward it if exists, track as "implicit constructor call" if not
  - Avoids the complexity and misleading metrics of synthetic methods
  - Still achieves the goal of prioritizing constructors for annotation

  This approach would:
  - Eliminate Step 2 (synthetic generation) entirely
  - Simplify Step 3 (no need to merge synthetic methods)
  - Avoid misleading parameter coverage metrics
  - Reduce code complexity while solving the core problem

DONE update the init doc after the refactor

TODO come back and handle this:
  ### Parameter Inference Limitations
  **Important**: The current implementation will NOT infer parameters from parent classes. A synthetic `__init__` always has just `(self)` as its parameter, even if the parent class has a different signature. This means:
  - `Child(42, "hello")` counts as a call to `Child.__init__`
  - Our synthetic `Child.__init__` only has `(self)` parameter
  - This parameter mismatch is intentional - we count calls, not validate them
  - This limitation will be addressed in future inheritance support

  (honestly maybe this doesn't even matter)

TODO break up tests/helpers/function_parsing.py?

ok!!!

i guess next up is property support??
i'm honestly not 100% sure what i think about this - but let's investigate and see if it turns out to be trivial

(properties don't take inputs, so do i actually care about this? i guess just for minimizing unresolvability?)

===

9/25

DONE i see integration tests in https://github.com/jrheard/annotation_prioritizer/blob/main/tests/unit/test_parse_ast.py

DONE establish clear guidelines for unit/integration tests in tests/CLAUDE.md

ok i ran into docker space issues
had claude set up a launchd service that runs docker system prune for me on sunday mornings
neat

TODO consider supporting a command-line flag that controls whether or not functions need a return type annotation to be considered "fully annotated" - what would we use as the default? "yes they do need that"?
  something about --explicit-return-type maybe

TODO dig around in test_unsupported.py next time i'm looking for something to work on

===

9/26

TODO someday read through vulture's codebase and see how they do all this

ok let's read the import doc again and use /review-plan on it

DONE will lookup_import() be a perf bottleneck?
  not yet, can figure it out later

DONE follow up on this
  The ImportRegistry.lookup_import scope checking logic uses string prefix matching which could have edge cases with similarly named scopes. Consider whether exact scope parent checking would be more robust

ok let's make a new branch and start work

DONE move test to test_unsupported, not test_call_count

TODO why check imports FIRST rather than LAST?
  actually last would be wrong too
  it's more complicated than that

TODO instead of QualifiedName strings, should we passing around lists of scope tuples??

TODO fix position-sensitive name support
  TODO https://github.com/jrheard/annotation_prioritizer/issues/31

  this is a can of worms!!!

im just gonna remove context7

DONE   4. Inconsistent Import Handling: Plan says imports have qualified_name=None in Phase 1, but Step 8 shows tracking process = sqrt where sqrt would be an import. How can we track that a variable references an import if imports have
  no resolvable qualified name?

TODO someday - distant future - comprehension variables?
  we should at least track this in test_unsupported.py

TODO reread doc from scratch on monday

TODO make sure i understand the proposed shape of PositionIndex. why is it dict[qualified_name][str] instead of dict[qualified_name]?

TODO /review-plan on this single-pass doc at _least_ one more time

TODO as part of the final PR review phase, we should run both main and the new branch on the demo files to verify we didn't lose functionality

TODO do a perf/memory investigation about the behavior/characeristics of using ScopeStacks everywhere vs using strings everywhere

TODO the main operation we're performing is prefix-based lookups - would a trie or some other data structure be relevant??

TODO investigate using a format like 'm:foo.c:bar.f:baz:v.quux' for qualified names, so it's not lossy compared to scopestack

TODO consider a /make-prototype command that takes a plan file as input, spins up a new branch, and makes a quick prototype of it
  to validate that the plan can work as written, to look for surprise missing prereqs, etc

  including a prototype_findings.md file at the end maybe, or maybe that can be a separate command to serve as a checkpoint

  i used this prompt for now

  > write a prototype_findings.md file that contains your findings from this prototype. what are the strengths of the plan doc? what
   are the weaknesses? does the plan doc contain inaccuracies? are there parts where the doc was unintentionally underspecified
  and you had to figure things out for yourself? etc. basically, what did you wish you knew before starting work on this
  prototype?

  but i had to prompt it to be more detailed, its initial output was vague at times

Bash(python test_prototype.py)
  âŽ¿  ============================================================
     Testing: test_shadowing_prototype.py
     ============================================================

     --- CURRENT IMPLEMENTATION ---
     Unresolvable calls: 7
       Line 10: sqrt(16)
       Line 18: sqrt(25)
       Line 21: Counter()
       Line 28: Counter()
       Line 31: Counter()
       ... and 2 more

     Function call counts:
       __module__.sqrt: 0 calls
       __module__.Counter.__init__: 0 calls
       __module__.outer.sqrt: 0 calls

     --- PROTOTYPE IMPLEMENTATION ---
     Unresolvable calls: 4
       Line 10: sqrt(16)
       Line 21: Counter()  # Should be unresolvable (import)
       Line 31: Counter()  # Should be unresolvable again (import)
       Line 48: calc.compute(10)  # Should resolve to Calculator.compute (if we tracked variables)

     Function call counts:
       __module__.sqrt: 2 calls
       __module__.outer.sqrt: 1 calls
       __module__.Counter.__init__: 1 calls

     --- DIFFERENCES ---
     âœ“ Lines now correctly resolved by prototype: [18, 28, 35, 40]
     âœ— Lines now unresolvable in prototype: [48]

     Function call count changes:
       __module__.sqrt: 0 -> 2
       __module__.outer.sqrt: 0 -> 1
       __module__.Counter.__init__: 0 -> 1
       __module__.Calculator.compute: 1 -> 0

     ============================================================
     Testing regular file for regression...

     ============================================================
     Testing: src/annotation_prioritizer/cli.py
     ============================================================

     --- CURRENT IMPLEMENTATION ---
     Unresolvable calls: 22
       Line 13: logging.getLogger(__name__)
       Line 18: argparse.ArgumentParser(
             description="Analyze Python files to prioritize type annotation additions"
         )
       Line 21: parser.add_argument(
             "target",
             help="Python file to analyze",
             type=Path,
         )
       Line 26: parser.add_argument(
             "--min-calls",
             type=int,
             default=0,
             help="Filter functions with fewer than N calls (default: 0)",
         )
       Line 32: parser.add_argument(
             "--debug",
             action="store_true",
             help="Enable debug logging output",
         )
       ... and 17 more

     Function call counts:

     --- PROTOTYPE IMPLEMENTATION ---
     Unresolvable calls: 24
       Line 13: logger = logging.getLogger(__name__)
       Line 18: parser = argparse.ArgumentParser(
       Line 21: parser.add_argument(
       Line 26: parser.add_argument(
       Line 32: parser.add_argument(
       ... and 19 more

     Function call counts:

     --- DIFFERENCES ---
     No lines fixed
     âœ— Lines now unresolvable in prototype: [77]

     Function call count changes:

TODO use prototype_findings.md to update the doc

and honestly maybe do this prototype approach _again_ once the doc feels like it's in a good state, seems valuable

hrm

PROTOTYPE VS ORIGINAL IMPLEMENTATION COMPARISON
     ============================================================

     ============================================================
     Testing: Shadowing bug test cases
     File: test_shadowing_prototype.py
     ============================================================

     --- UNRESOLVABLE CALLS ---
     Original: 7 lines
     Prototype: 3 lines

     âœ“ FIXED by prototype (now resolved): [20, 34, 43, 48]
       Line 20: sqrt(25)
       Line 34: Counter()
       Line 43: sqrt(36)

     --- FUNCTION CALL COUNTS ---
     âœ“ NEW: __module__.Counter.__init__: 1 calls (was untracked)
     âœ“ NEW: __module__.outer.sqrt: 1 calls (was untracked)
     âœ“ NEW: __module__.sqrt: 2 calls (was untracked)

     ============================================================
     SHADOWING TEST CASES
     ============================================================

     --- Function shadows import ---
     Original unresolved: 1
     Prototype unresolved: 0
     âœ“ Prototype BETTER

     --- Inner function shadows outer ---
     Original unresolved: 0
     Prototype unresolved: 0
     = Same result

     --- Variable tracks class ---
     Original unresolved: 0
     Prototype unresolved: 0
     = Same result

     ============================================================
     SUMMARY
     ============================================================
     âœ“ Total lines fixed by prototype: 4
     âœ— Total regressions in prototype: 0

     âœ… PROTOTYPE IS STRICTLY BETTER
     The prototype fixes bugs with no regressions.

     Key achievements:
     1. Fixes Python shadowing semantics (issue #31)
     2. Single-pass architecture (5x fewer AST traversals)
     3. O(log k) lookup performance vs O(n)
     4. Cleaner, more maintainable codebase
     5. With variable tracking: feature parity achieved

    ============================================================
     CONCRETE EXAMPLE: How Prototype Fixes Shadowing
     ============================================================

     CODE:
     # Line 1
     from math import sqrt  # Import sqrt

     def sqrt(x):  # Line 4: Function shadows import
         return x ** 0.5

     result = sqrt(25)  # Line 7: Which sqrt?

     RESOLUTION AT LINE 7:
     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     Original Implementation:
       1. Sees 'sqrt' is imported (line 2)
       2. Sees 'sqrt' is defined (line 4)
       3. Can't determine which applies âŒ
       4. Result: UNRESOLVED

     Prototype Implementation:
       1. Binary search for 'sqrt' before line 7
       2. Finds: Line 4 definition (most recent)
       3. Correctly shadows the import âœ…
       4. Result: Resolves to __module__.sqrt
