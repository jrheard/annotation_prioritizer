# Fix Method Call Attribution Bug - Implementation Plan

**Date**: 2025-09-12  
**Goal**: Fix critical bug where instance method calls (`calc.add()`) are not being counted due to qualified name mismatch

## Problem Analysis

### Current Bug Behavior
- **Expected**: `calc.add(1, 2)` should count toward `Calculator.add`
- **Actual**: `Calculator.add` shows 0 calls, `Calculator.multiply` shows 0 calls (should be 2)
- **Root Cause**: Variable name vs class name mismatch in qualified name resolution

### Technical Details
```python
# Demo code pattern:
calc = Calculator()        # Variable assignment
calc.add(1, 2)            # Instance method call

# What call counter sees:
# - AST.Attribute with value.id="calc", attr="add"  
# - Current logic returns "calc.add"

# What parser generates:
# - Method qualified name: "Calculator.add"

# Result: "calc.add" ≠ "Calculator.add" → no match → count = 0
```

## Solution: Variable Type Resolution

Implement assignment tracking to resolve variable types and correctly attribute method calls.

## Implementation Plan

### Step 1: Enhance CallCountVisitor Data Structures

**File**: `src/annotation_prioritizer/call_counter.py`

Add variable type tracking to the visitor:

```python
class CallCountVisitor(ast.NodeVisitor):
    def __init__(self, call_counts: dict[str, int]) -> None:
        self.call_counts = call_counts
        self.class_stack: list[str] = []
        # NEW: Track variable type assignments
        self.variable_types: dict[str, str] = {}
```

### Step 2: Implement Assignment Detection

Add a new visitor method to track variable assignments:

```python
def visit_Assign(self, node: ast.Assign) -> None:
    """Track variable assignments to detect type information."""
    # Handle single target assignments: var = Constructor()
    if len(node.targets) == 1 and isinstance(node.targets[0], ast.Name):
        var_name = node.targets[0].id
        constructor_name = self._extract_constructor_name(node.value)
        if constructor_name:
            self.variable_types[var_name] = constructor_name
    
    self.generic_visit(node)

def _extract_constructor_name(self, node: ast.expr) -> str | None:
    """Extract class name from constructor call expressions."""
    # Handle: ClassName()
    if isinstance(node, ast.Call) and isinstance(node.func, ast.Name):
        return node.func.id
    
    # Handle: module.ClassName() - extract just ClassName for same-module analysis
    if isinstance(node, ast.Call) and isinstance(node.func, ast.Attribute):
        return node.func.attr
    
    return None
```

### Step 3: Enhance Call Name Resolution

Modify `_extract_call_name` to use variable type information:

```python
def _extract_call_name(self, node: ast.Call) -> str | None:
    """Extract the qualified name of the called function."""
    func = node.func

    # Direct function call: function_name()
    if isinstance(func, ast.Name):
        return func.id

    # Method call: obj.method_name()
    if isinstance(func, ast.Attribute):
        # Handle self.method_name() calls (unchanged)
        if isinstance(func.value, ast.Name) and func.value.id == "self":
            if self.class_stack:
                return ".".join([*self.class_stack, func.attr])
            return func.attr

        # NEW: Handle instance method calls via variables
        if isinstance(func.value, ast.Name):
            var_name = func.value.id
            
            # Check if we know the type of this variable
            if var_name in self.variable_types:
                class_name = self.variable_types[var_name]
                return f"{class_name}.{func.attr}"
            
            # Fallback: assume it's a class name (ClassName.static_method)
            return f"{var_name}.{func.attr}"

        # Handle qualified calls within same module (unchanged)
        if isinstance(func.value, ast.Attribute):
            return func.attr

    return None
```

### Step 4: Add Comprehensive Test Cases

**File**: `tests/unit/test_call_counter.py`

Add test cases to cover the new functionality:

```python
def test_instance_method_calls_via_variables():
    """Test that instance method calls are correctly attributed."""
    test_file = tmp_path / "test_instance_calls.py"
    test_file.write_text("""
class Calculator:
    def add(self, x: int, y: int) -> int:
        return x + y
    
    def multiply(self, x, y):
        return x * y

def main():
    calc = Calculator()
    result1 = calc.add(1, 2)      # Should count toward Calculator.add
    result2 = calc.multiply(3, 4)  # Should count toward Calculator.multiply
    result3 = calc.multiply(5, 6)  # Should count toward Calculator.multiply
""")
    
    # Parse functions
    functions = parse_function_definitions(str(test_file))
    
    # Count calls
    call_counts = count_function_calls(str(test_file), functions)
    call_count_dict = {cc.function_qualified_name: cc.call_count for cc in call_counts}
    
    # Verify correct attribution
    assert call_count_dict["Calculator.add"] == 1
    assert call_count_dict["Calculator.multiply"] == 2
    assert call_count_dict["main"] == 1  # Called implicitly if __main__ block exists

def test_mixed_assignment_patterns():
    """Test various assignment patterns."""
    test_file = tmp_path / "test_assignments.py"
    test_file.write_text("""
class Handler:
    def process(self): pass

def main():
    # Direct assignment
    h1 = Handler()
    h1.process()
    
    # Multiple variables same type  
    h2 = Handler()
    h2.process()
    
    # Reassignment
    h3 = Handler()
    h3 = Handler()  # Should update type tracking
    h3.process()
""")
    
    functions = parse_function_definitions(str(test_file))
    call_counts = count_function_calls(str(test_file), functions)
    call_count_dict = {cc.function_qualified_name: cc.call_count for cc in call_counts}
    
    assert call_count_dict["Handler.process"] == 3

def test_unknown_variable_calls():
    """Test behavior with unknown variables (parameters, etc.)."""
    test_file = tmp_path / "test_unknown_vars.py"  
    test_file.write_text("""
class Processor:
    def run(self): pass

def process_with_param(obj):
    # obj type unknown - should not be counted
    obj.run()
    
def process_with_known():
    proc = Processor()
    proc.run()  # Should be counted
""")
    
    functions = parse_function_definitions(str(test_file))
    call_counts = count_function_calls(str(test_file), functions)
    call_count_dict = {cc.function_qualified_name: cc.call_count for cc in call_counts}
    
    # Only the known assignment should be counted
    assert call_count_dict["Processor.run"] == 1
```

### Step 5: Integration Test Update

**File**: `tests/integration/test_end_to_end.py`

Update existing integration tests to verify the fix:

```python
def test_method_call_attribution_fix():
    """Verify that the method call attribution bug is fixed."""
    test_file = tmp_path / "integration_test.py"
    test_file.write_text("""
class Calculator:
    def add(self, x: int, y: int) -> int:
        return x + y
    
    def multiply(self, x, y):  # Unannotated
        return x * y

def process_data(data):  # Unannotated, high usage
    return data.upper()

def main():
    calc = Calculator()
    
    # High-usage unannotated function
    process_data("test1")
    process_data("test2") 
    process_data("test3")
    
    # Method calls that should be counted
    calc.add(1, 2)
    calc.multiply(3, 4)
    calc.multiply(5, 6)
""")
    
    result = analyze_file(str(test_file))
    result_dict = {fp.function_info.qualified_name: fp for fp in result}
    
    # Verify method calls are counted correctly
    assert result_dict["Calculator.add"].call_count == 1
    assert result_dict["Calculator.multiply"].call_count == 2
    
    # Verify priority scoring works correctly
    # process_data: 3 calls, 0% annotated → priority = 3.0
    # Calculator.multiply: 2 calls, 0% annotated → priority = 2.0  
    # Calculator.add: 1 call, 100% annotated → priority = 0.0
    
    assert result_dict["process_data"].priority_score == 3.0
    assert result_dict["Calculator.multiply"].priority_score == 2.0
    assert result_dict["Calculator.add"].priority_score == 0.0
```

## Assumptions and Dependencies

### Assumptions
1. **Same-module scope**: Only handling assignments within the analyzed file
2. **Simple assignment patterns**: Focus on `var = ClassName()` patterns initially
3. **No aliasing complexity**: Not handling `var1 = var2` assignment chains
4. **Constructor identification**: Assuming `Name()` calls are constructor calls

### Dependencies
- No new external dependencies required
- Existing AST parsing infrastructure sufficient
- Current test framework adequate

### Future Enhancement Opportunities
- **Import resolution**: Track imported class names for cross-module analysis
- **Assignment chains**: Handle `var1 = var2 = ClassName()`
- **Complex expressions**: Support `var = some_function_returning_class()`
- **Type annotations**: Use existing type annotations to infer variable types

## Edge Cases to Consider

### Handled in Initial Implementation
- Multiple variables of same type
- Variable reassignment (last assignment wins)
- Constructor calls with arguments
- Mixed method and function calls

### Deferred for Later
- Function calls returning instances: `var = factory_function()`  
- Assignment chains: `a = b = ClassName()`
- Conditional assignments: `var = Class1() if condition else Class2()`
- Import-based constructors: `var = imported.ClassName()`

## Success Metrics

### Immediate Success Criteria
1. **Demo file fix**: `Calculator.add` shows 1 call, `Calculator.multiply` shows 2 calls
2. **Test coverage**: All new functionality covered by unit tests  
3. **Integration tests pass**: End-to-end scenarios work correctly
4. **No regressions**: Direct function calls continue to work

### Performance Expectations
- Minimal performance impact (single AST pass)
- Memory overhead scales linearly with number of assignments
- No change to overall analysis time complexity

## Implementation Sequence

1. **Implement data structures** (5 min)
2. **Add assignment detection** (15 min)  
3. **Enhance call resolution** (10 min)
4. **Write unit tests** (30 min)
5. **Update integration tests** (10 min)
6. **Test with demo files** (5 min)
7. **Run full test suite** (5 min)

**Total estimated time**: ~90 minutes

This implementation will resolve the immediate method call attribution bug while establishing the foundation for more sophisticated variable type resolution in future iterations.